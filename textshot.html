<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vintage Textshot Generator</title>
    <!-- Google Fonts for Vintage Aesthetic -->
    <link href="https://fonts.googleapis.com/css2?family=Playfair+Display:wght@400;700&family=Oswald:wght@300;400;600&family=Bebas+Neue&family=Crimson+Text:ital@0;1&family=Libre+Baskerville:ital@0;1&family=Merriweather:wght@300;400;700&family=Lora:ital@0;1&family=Old+Standard+TT:ital@0;1&family=Vollkorn:wght@400;600&family=Bitter:wght@400;600&family=Alegreya:ital@0;1&family=Cormorant+Garamond:ital@0;1&family=EB+Garamond:ital@0;1&family=Source+Sans+Pro:wght@300;400;600&family=Montserrat:wght@300;400;600&family=Roboto+Slab:wght@300;400;600&family=Special+Elite&family=Major+Mono+Display&family=Space+Mono&family=Fredoka+One&family=Righteous&family=Anton&family=Shadows+Into+Light&family=Caveat:wght@400;600&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #FED16A, #FFF4A4);
            margin: 0;
            padding: 20px;
            min-height: 100vh;
            line-height: 1.6;
        }

        .container {
            max-width: 700px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }

        .header {
            text-align: center;
            background: linear-gradient(135deg, #FED16A, #F97A00);
            color: #386641;
            padding: 30px 20px;
            border-radius: 15px;
            margin-bottom: 25px;
            box-shadow: 0 4px 15px rgba(254, 209, 106, 0.3);
        }

        .header h1 {
            margin: 0 0 10px 0;
            font-size: 2.2em;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            margin: 0;
            font-size: 1.1em;
            opacity: 0.9;
        }

        .section {
            margin-bottom: 25px;
            padding: 20px;
            border: 2px solid #e8e8e8;
            border-radius: 12px;
            background: #fafafa;
            transition: border-color 0.3s ease;
        }

        .section:hover {
            border-color: #F97A00;
        }

        .section h3 {
            margin: 0 0 15px 0;
            color: #386641;
            font-size: 1.3em;
            font-weight: bold;
        }

        .color-presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .color-preset {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .color-preset:hover {
            border-color: #386641;
            transform: scale(1.1);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }

        .preset-bg, .preset-fg {
            position: absolute;
            width: 50%;
            height: 100%;
        }

        .preset-bg {
            left: 0;
            border-radius: 50% 0 0 50%;
        }

        .preset-fg {
            right: 0;
            border-radius: 0 50% 50% 0;
        }

        input[type="checkbox"] {
            width: 20px !important;
            height: 20px;
            accent-color: #386641;
            cursor: pointer;
        }

        .input-group label {
            font-weight: 500;
            color: #555;
            min-width: 100px;
            display: flex;
            align-items: center;
        }

        textarea, input[type="text"], input[type="color"], select {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            margin-bottom: 15px;
            font-size: 16px;
            font-family: inherit;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        textarea:focus, input:focus, select:focus {
            outline: none;
            border-color: #386641;
            box-shadow: 0 0 0 3px rgba(56, 102, 65, 0.1);
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
        }

        .input-group label {
            font-weight: 500;
            color: #555;
            min-width: 100px;
        }

        .input-group input[type="range"] {
            flex: 1;
            margin: 0;
        }

        .input-group input[type="color"] {
            width: 60px;
            height: 40px;
            padding: 0;
            border-radius: 6px;
            cursor: pointer;
        }

        .size-option {
            display: block;
            width: 100%;
            padding: 15px 20px;
            margin-bottom: 10px;
            border: 2px solid #ddd;
            background: white;
            border-radius: 10px;
            cursor: pointer;
            text-align: left;
            font-size: 16px;
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .size-option:hover {
            border-color: #386641;
            background: #f8f8f8;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .size-option.selected {
            border-color: #386641;
            background: #386641;
            color: white;
            box-shadow: 0 4px 15px rgba(56, 102, 65, 0.3);
        }

        .size-name {
            font-weight: bold;
            display: block;
            margin-bottom: 4px;
        }

        .size-dims {
            font-size: 14px;
            opacity: 0.8;
        }

        .pattern-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 12px;
            margin-top: 15px;
        }

        .pattern-btn {
            position: relative;
            width: 70px;
            height: 70px;
            border: 3px solid #ddd;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            background: white;
        }

        .pattern-btn:hover {
            border-color: #386641;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .pattern-btn.selected {
            border-color: #386641;
            border-width: 4px;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(56, 102, 65, 0.3);
        }

        .pattern-btn canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .pattern-name {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.8);
            color: white;
            font-size: 10px;
            padding: 4px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .pattern-btn:hover .pattern-name {
            opacity: 1;
        }

        #canvas {
            max-width: 100%;
            border: 3px solid #386641;
            border-radius: 15px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            background: white;
        }

        .canvas-container {
            text-align: center;
            padding: 20px 0;
        }

        .buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 25px;
        }

        button {
            padding: 15px 20px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #FED16A, #F97A00);
            color: #386641;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(254, 209, 106, 0.3);
        }

        .btn-primary:hover {
            background: linear-gradient(135deg, #F97A00, #FED16A);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(254, 209, 106, 0.4);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #FED16A, #F97A00);
            color: #386641;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(254, 209, 106, 0.3);
        }

        .btn-secondary:hover {
            background: linear-gradient(135deg, #F97A00, #FED16A);
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(254, 209, 106, 0.4);
        }

        .status {
            text-align: center;
            padding: 15px;
            margin: 15px 0;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.4;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .status.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading {
            opacity: 0.6;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 15px;
            }
            
            .pattern-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }
            
            .pattern-btn {
                width: 60px;
                height: 60px;
            }
            
            .buttons {
                grid-template-columns: 1fr;
                gap: 10px;
            }
            
            .input-group {
                flex-direction: column;
                align-items: stretch;
            }
            
            .input-group label {
                min-width: auto;
                margin-bottom: 5px;
            }
        }

        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 20px;
            color: #666;
            font-size: 14px;
        }

        .footer a {
            color: #386641;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>TextShot Love</h1>
        </div>

        <div class="section">
            <h3>üìù Text Input</h3>
            <textarea id="mainText" rows="4" placeholder="Enter your inspirational quote or text here..."></textarea>
            <input type="text" id="authorText" placeholder="Author or attribution (optional)">
        </div>

        <div class="section">
            <h3>üé® Text Settings</h3>
            <select id="fontSelect">
                <!-- Classic Vintage Serifs -->
                <option value="'Playfair Display', Georgia, serif">Playfair Display (Elegant Vintage)</option>
                <option value="'Crimson Text', Georgia, serif">Crimson Text (Classic Book)</option>
                <option value="'Libre Baskerville', Georgia, serif">Libre Baskerville (18th Century)</option>
                <option value="'Merriweather', Georgia, serif">Merriweather (Friendly Readable)</option>
                <option value="'Lora', Georgia, serif">Lora (Contemporary Classic)</option>
                <option value="'Old Standard TT', 'Times New Roman', serif">Old Standard (Imperial Russian)</option>
                <option value="'Vollkorn', Georgia, serif">Vollkorn (Quiet & Modest)</option>
                <option value="'Bitter', Georgia, serif">Bitter (Sharp & Precise)</option>
                <option value="'Alegreya', Georgia, serif">Alegreya (Humanist)</option>
                <option value="'Cormorant Garamond', Garamond, serif">Cormorant Garamond (Renaissance)</option>
                <option value="'EB Garamond', Garamond, serif">EB Garamond (Classic French)</option>
                
                <!-- Mid-Century Sans Serifs -->
                <option value="'Oswald', 'Arial Narrow', sans-serif">Oswald (Modern Condensed)</option>
                <option value="'Source Sans Pro', Arial, sans-serif">Source Sans Pro (Clean & Simple)</option>
                <option value="'Montserrat', Helvetica, sans-serif">Montserrat (Geometric Urban)</option>
                <option value="'Bebas Neue', Impact, sans-serif">Bebas Neue (Bold Display)</option>
                <option value="'Righteous', Arial, sans-serif">Righteous (Vintage Signage)</option>
                <option value="'Anton', Impact, sans-serif">Anton (Strong Impact)</option>
                <option value="'Fredoka One', Arial, sans-serif">Fredoka One (Friendly Bold)</option>
                
                <!-- Slab Serifs (Mid-Century Style) -->
                <option value="'Roboto Slab', Georgia, serif">Roboto Slab (Modern Mechanical)</option>
                
                <!-- Typewriter & Monospace -->
                <option value="'Special Elite', 'Courier New', monospace">Special Elite (Vintage Typewriter)</option>
                <option value="'Major Mono Display', 'Courier New', monospace">Major Mono Display (Bold Mono)</option>
                <option value="'Space Mono', 'Courier New', monospace">Space Mono (Retro Future)</option>
                <option value="'Courier New', Courier, monospace">Courier New (Classic Typewriter)</option>
                
                <!-- Handwritten & Script -->
                <option value="'Shadows Into Light', cursive">Shadows Into Light (Casual Script)</option>
                <option value="'Caveat', cursive">Caveat (Personal Handwriting)</option>
                
                <!-- Web Safe Fallbacks -->
                <option value="Georgia, serif">Georgia (Web Safe Serif)</option>
                <option value="'Times New Roman', Times, serif">Times New Roman (Traditional)</option>
                <option value="Arial, Helvetica, sans-serif">Arial (Clean Sans-Serif)</option>
                <option value="Helvetica, Arial, sans-serif">Helvetica (Swiss Design)</option>
                <option value="Verdana, Geneva, sans-serif">Verdana (Screen Optimized)</option>
                <option value="'Trebuchet MS', Helvetica, sans-serif">Trebuchet MS (Humanist)</option>
                <option value="Impact, 'Arial Black', sans-serif">Impact (Bold Display)</option>
            </select>
            <div class="input-group">
                <label>Text Size:</label>
                <input type="range" id="textSize" min="20" max="160" value="80">
                <span id="textSizeValue">80px</span>
            </div>
            <div class="input-group">
                <label>Text Color:</label>
                <input type="color" id="textColor" value="#2c1810">
            </div>
        </div>

        <div class="section">
            <h3>üé® Background Pattern</h3>
            <div class="input-group">
                <label>Background:</label>
                <input type="color" id="patternBgColor" value="#FFF4A4">
            </div>
            <div class="input-group">
                <label>Pattern Color:</label>
                <input type="color" id="patternFgColor" value="#386641">
            </div>
            <div style="margin-bottom: 15px;">
                <label style="font-weight: 500; color: #555; margin-bottom: 8px; display: block;">Color Presets:</label>
                <div class="color-presets">
                    <div class="color-preset" onclick="applyColorPreset('#9ECAD6', '#748DAE')" title="Ocean Breeze">
                        <div class="preset-bg" style="background: #9ECAD6;"></div>
                        <div class="preset-fg" style="background: #748DAE;"></div>
                    </div>
                    <div class="color-preset" onclick="applyColorPreset('#EAC8A6', '#DC3C22')" title="Warm Earth">
                        <div class="preset-bg" style="background: #EAC8A6;"></div>
                        <div class="preset-fg" style="background: #DC3C22;"></div>
                    </div>
                    <div class="color-preset" onclick="applyColorPreset('#00809D', '#FCF8DD')" title="Deep Sea">
                        <div class="preset-bg" style="background: #00809D;"></div>
                        <div class="preset-fg" style="background: #FCF8DD;"></div>
                    </div>
                    <div class="color-preset" onclick="applyColorPreset('#932F67', '#D92C54')" title="Bold Berry">
                        <div class="preset-bg" style="background: #932F67;"></div>
                        <div class="preset-fg" style="background: #D92C54;"></div>
                    </div>
                    <div class="color-preset" onclick="applyColorPreset('#789DBC', '#FFE3E3')" title="Soft Sky">
                        <div class="preset-bg" style="background: #789DBC;"></div>
                        <div class="preset-fg" style="background: #FFE3E3;"></div>
                    </div>
                    <div class="color-preset" onclick="applyColorPreset('#B7E0FF', '#FFF5CD')" title="Light Dreams">
                        <div class="preset-bg" style="background: #B7E0FF;"></div>
                        <div class="preset-fg" style="background: #FFF5CD;"></div>
                    </div>
                </div>
            </div>
            <div class="pattern-grid" id="patternGrid"></div>
        </div>

        <div class="section">
            <h3>üñºÔ∏è Frame Options</h3>
            <div class="input-group">
                <label>
                    <input type="checkbox" id="enableBorder" style="width: auto; margin-right: 10px;">
                    Add Border
                </label>
            </div>
            <div class="input-group">
                <label>Border Width:</label>
                <input type="range" id="borderWidth" min="5" max="50" value="10" disabled>
                <span id="borderWidthValue">10px</span>
            </div>
            <div class="input-group">
                <label>Border Color:</label>
                <input type="color" id="borderColor" value="#386641" disabled>
            </div>
            <div class="input-group">
                <label>
                    <input type="checkbox" id="enableRoundedCorners" style="width: auto; margin-right: 10px;">
                    Rounded Corners
                </label>
            </div>
            <div class="input-group">
                <label>Corner Radius:</label>
                <input type="range" id="cornerRadius" min="10" max="100" value="30" disabled>
                <span id="cornerRadiusValue">30px</span>
            </div>
        </div>

        <div class="section">
            <h3>üì± Export Size</h3>
            <div id="sizeOptions">
                <button class="size-option selected" onclick="selectSize(1080, 1080, 'Instagram Square', this)">
                    <span class="size-name">Instagram Square</span>
                    <span class="size-dims">1080 √ó 1080px</span>
                </button>
                <button class="size-option" onclick="selectSize(1080, 1350, 'Instagram Portrait', this)">
                    <span class="size-name">Instagram Portrait</span>
                    <span class="size-dims">1080 √ó 1350px</span>
                </button>
                <button class="size-option" onclick="selectSize(1080, 1920, 'Instagram Stories', this)">
                    <span class="size-name">Instagram Stories</span>
                    <span class="size-dims">1080 √ó 1920px</span>
                </button>
                <button class="size-option" onclick="selectSize(1200, 628, 'Facebook/LinkedIn', this)">
                    <span class="size-name">Facebook/LinkedIn</span>
                    <span class="size-dims">1200 √ó 628px</span>
                </button>
                <button class="size-option" onclick="selectSize(1200, 675, 'Bluesky/Mastodon', this)">
                    <span class="size-name">Bluesky/Mastodon</span>
                    <span class="size-dims">1200 √ó 675px</span>
                </button>
                <button class="size-option" onclick="selectSize(1000, 1500, 'Pinterest', this)">
                    <span class="size-name">Pinterest</span>
                    <span class="size-dims">1000 √ó 1500px</span>
                </button>
                <button class="size-option" onclick="selectSize(2000, 2000, 'High Resolution', this)">
                    <span class="size-name">High Resolution</span>
                    <span class="size-dims">2000 √ó 2000px</span>
                </button>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="canvas" width="800" height="800"></canvas>
        </div>

        <div class="buttons">
            <button class="btn-primary" onclick="downloadImage()">üì• Download Image</button>
            <button class="btn-secondary" onclick="copyImage()">üìã Share/Copy</button>
        </div>

        <div id="status"></div>
    </div>

    <script>
        let currentWidth = 1080;
        let currentHeight = 1080;
        let currentSizeName = 'Instagram Square';
        let currentPattern = 0;

        // Shakespeare couplets for random default text
        const shakespeareCouplets = [
            "So long as men can breathe or eyes can see,\nSo long lives this, and this gives life to thee.",
            "For thy sweet love remembered such wealth brings\nThat then I scorn to change my state with kings.",
            "If this be error and upon me proved,\nI never writ, nor no man ever loved.",
            "And yet, by heaven, I think my love as rare\nAs any she belied with false compare.",
            "But if the while I think on thee, dear friend,\nAll losses are restored and sorrows end.",
            "Shall I compare thee to a summer's day?\nThou art more lovely and more temperate.",
            "But thy eternal summer shall not fade,\nNor lose possession of that fair thou ow'st.",
            "When in disgrace with fortune and men's eyes\nI all alone beweep my outcast state",
            "Love is not love which alters when it alteration finds,\nOr bends with the remover to remove",
            "My mistress' eyes are nothing like the sun;\nCoral is far more red than her lips' red",
            "Good night, good night! Parting is such sweet sorrow\nThat I shall say good night till it be morrow",
            "This above all: to thine own self be true,\nAnd it must follow, as the night the day",
            "The course of true love never did run smooth;\nBut either it was different in blood",
            "All the world's a stage,\nAnd all the men and women merely players",
            "If music be the food of love, play on;\nGive me excess of it, that, surfeiting",
            "To be or not to be, that is the question:\nWhether 'tis nobler in the mind to suffer",
            "What light through yonder window breaks?\nIt is the east, and Juliet is the sun",
            "Some are born great, some achieve greatness,\nAnd some have greatness thrust upon 'em",
            "Now is the winter of our discontent\nMade glorious summer by this son of York",
            "Double, double toil and trouble;\nFire burn and cauldron bubble",
            "Fair is foul, and foul is fair:\nHover through the fog and filthy air",
            "When shall we three meet again\nIn thunder, lightning, or in rain?",
            "Out, out, brief candle!\nLife's but a walking shadow, a poor player",
            "We are such stuff as dreams are made on,\nAnd our little life is rounded with a sleep",
            "Better a witty fool than a foolish wit,\nFor folly that he wisely shows is fit"
        ];

        function getRandomShakespeareCouplet() {
            return shakespeareCouplets[Math.floor(Math.random() * shakespeareCouplets.length)];
        }

        const patterns = [
            {name: 'Atomic Starburst', type: 'starburst', color1: '#f4e4bc', color2: '#d4a574', accent: '#8b4513'},
            {name: 'Boomerang Scatter', type: 'boomerang', color1: '#fff8dc', color2: '#deb887', accent: '#cd853f'},
            {name: 'Atomic Dots', type: 'atomic_dots', color1: '#faf0e6', color2: '#bc8f8f', accent: '#8b4513'},
            {name: 'Mid-Century Zigzag', type: 'zigzag', color1: '#f5f5dc', color2: '#a0522d', accent: '#654321'},
            {name: 'Retro Triangles', type: 'triangles', color1: '#fff8dc', color2: '#d2b48c', accent: '#a0522d'},
            {name: 'Diamond Grid', type: 'diamond', color1: '#f5f5dc', color2: '#a0522d', accent: '#654321'},
            {name: 'Geometric Waves', type: 'waves', color1: '#f0e68c', color2: '#b8860b', accent: '#8b7d6b'},
            {name: 'Retro Stripes', type: 'retro_stripes', color1: '#fdf5e6', color2: '#daa520', accent: '#b8860b'},
            {name: 'Color Blocks', type: 'blocks', color1: '#ffe4b5', color2: '#cd853f', accent: '#8b4513'},
            {name: 'Sunburst Radial', type: 'sunburst', color1: '#fdf5e6', color2: '#daa520', accent: '#b8860b'},
            {name: 'Overlapping Circles', type: 'circles', color1: '#ffe4b5', color2: '#cd853f', accent: '#b8860b'},
            {name: 'Angular Shapes', type: 'angular', color1: '#f0e68c', color2: '#b8860b', accent: '#8b7d6b'},
            {name: 'Curved Lines', type: 'curves', color1: '#faf0e6', color2: '#bc8f8f', accent: '#8b7d6b'},
            {name: 'Retro Hexagons', type: 'hexagons', color1: '#ffe4b5', color2: '#cd853f', accent: '#8b4513'},
            {name: 'Organic Shapes', type: 'organic', color1: '#ffe4b5', color2: '#d2b48c', accent: '#a0522d'},
            {name: 'Atomic Age Mix', type: 'atomic_age', color1: '#f4e4bc', color2: '#d4a574', accent: '#8b4513'},
            {name: 'Gold Cross Pattern', type: 'gold_cross', color1: '#fdf5e6', color2: '#daa520', accent: '#b8860b'},
            {name: 'Kidney Bean Shapes', type: 'kidney', color1: '#ffe4b5', color2: '#d2b48c', accent: '#a0522d'},
            {name: 'Abstract Leaves', type: 'leaves', color1: '#f4e4bc', color2: '#daa520', accent: '#8b6914'},
            {name: 'Vintage Plus Signs', type: 'crosses', color1: '#fff8dc', color2: '#d2b48c', accent: '#a0522d'}
        ];

        function init() {
            // Set random Shakespeare couplet as default text
            document.getElementById('mainText').value = getRandomShakespeareCouplet();
            
            createPatternButtons();
            updateCanvas();
            
            // Event listeners for existing controls
            document.getElementById('mainText').addEventListener('input', updateCanvas);
            document.getElementById('authorText').addEventListener('input', updateCanvas);
            document.getElementById('fontSelect').addEventListener('change', updateCanvas);
            document.getElementById('textSize').addEventListener('input', function() {
                document.getElementById('textSizeValue').textContent = this.value + 'px';
                updateCanvas();
            });
            document.getElementById('textColor').addEventListener('input', updateCanvas);
            
            // Event listeners for pattern colors
            document.getElementById('patternBgColor').addEventListener('input', function() {
                createPatternButtons(); // Recreate buttons with new colors
                updateCanvas();
            });
            document.getElementById('patternFgColor').addEventListener('input', function() {
                createPatternButtons(); // Recreate buttons with new colors
                updateCanvas();
            });
            
            // Event listeners for border controls
            document.getElementById('enableBorder').addEventListener('change', function() {
                const borderControls = ['borderWidth', 'borderColor'];
                borderControls.forEach(id => {
                    document.getElementById(id).disabled = !this.checked;
                });
                updateCanvas();
            });
            
            document.getElementById('borderWidth').addEventListener('input', function() {
                document.getElementById('borderWidthValue').textContent = this.value + 'px';
                updateCanvas();
            });
            
            document.getElementById('borderColor').addEventListener('input', updateCanvas);
            
            // Event listeners for rounded corners
            document.getElementById('enableRoundedCorners').addEventListener('change', function() {
                document.getElementById('cornerRadius').disabled = !this.checked;
                updateCanvas();
            });
            
            document.getElementById('cornerRadius').addEventListener('input', function() {
                document.getElementById('cornerRadiusValue').textContent = this.value + 'px';
                updateCanvas();
            });
        }

        function createPatternButtons() {
            const grid = document.getElementById('patternGrid');
            grid.innerHTML = ''; // Clear existing buttons
            
            patterns.forEach((pattern, index) => {
                const btn = document.createElement('div');
                btn.className = 'pattern-btn';
                if (index === 0) btn.classList.add('selected');
                
                // Create preview canvas
                const canvas = document.createElement('canvas');
                canvas.width = 70;
                canvas.height = 70;
                const ctx = canvas.getContext('2d');
                
                // Get current colors from UI
                const bgColor = document.getElementById('patternBgColor').value;
                const fgColor = document.getElementById('patternFgColor').value;
                
                // Create custom pattern object with current colors
                const customPattern = {
                    ...pattern,
                    color1: bgColor,
                    color2: bgColor,
                    accent: fgColor
                };
                
                // Draw accurate pattern preview
                drawPatternBackground(ctx, customPattern, 70, 70);
                
                // Add pattern name tooltip
                const nameSpan = document.createElement('span');
                nameSpan.className = 'pattern-name';
                nameSpan.textContent = pattern.name;
                
                btn.appendChild(canvas);
                btn.appendChild(nameSpan);
                btn.onclick = () => selectPattern(index);
                grid.appendChild(btn);
            });
        }

        function applyColorPreset(bgColor, fgColor) {
            // Update the color input values
            document.getElementById('patternBgColor').value = bgColor;
            document.getElementById('patternFgColor').value = fgColor;
            
            // Recreate pattern buttons with new colors
            createPatternButtons();
            
            // Update the main canvas
            updateCanvas();
        }

        function selectPattern(index) {
            // Update selection
            document.querySelectorAll('.pattern-btn').forEach((btn, i) => {
                btn.classList.toggle('selected', i === index);
            });
            currentPattern = index;
            updateCanvas();
        }

        function selectSize(width, height, name, element) {
            currentWidth = width;
            currentHeight = height;
            currentSizeName = name;
            
            document.querySelectorAll('.size-option').forEach(option => {
                option.classList.remove('selected');
            });
            element.classList.add('selected');
            
            updateCanvas();
        }

        function updateCanvas() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set actual canvas dimensions to export size
            canvas.width = currentWidth;
            canvas.height = currentHeight;
            
            // Set display size to show true aspect ratio (no responsive scaling)
            const baseSize = 300; // Base dimension for display
            const aspectRatio = currentWidth / currentHeight;
            let displayWidth, displayHeight;
            
            if (aspectRatio >= 1) {
                // Landscape or square - base the width
                displayWidth = baseSize;
                displayHeight = baseSize / aspectRatio;
            } else {
                // Portrait - base the height
                displayHeight = baseSize;
                displayWidth = baseSize * aspectRatio;
            }
            
            // Apply exact display size via CSS to show true aspect ratio
            canvas.style.width = displayWidth + 'px';
            canvas.style.height = displayHeight + 'px';
            
            // Clear canvas
            ctx.clearRect(0, 0, currentWidth, currentHeight);
            
            // Get frame settings
            const enableBorder = document.getElementById('enableBorder').checked;
            const borderWidth = parseInt(document.getElementById('borderWidth').value);
            const borderColor = document.getElementById('borderColor').value;
            const enableRoundedCorners = document.getElementById('enableRoundedCorners').checked;
            const cornerRadius = parseInt(document.getElementById('cornerRadius').value);
            
            // Calculate content area (inside border)
            const contentX = enableBorder ? borderWidth : 0;
            const contentY = enableBorder ? borderWidth : 0;
            const contentWidth = currentWidth - (enableBorder ? borderWidth * 2 : 0);
            const contentHeight = currentHeight - (enableBorder ? borderWidth * 2 : 0);
            
            // Save context for clipping
            ctx.save();
            
            // Create clipping path for rounded corners if enabled
            if (enableRoundedCorners) {
                roundedRect(ctx, contentX, contentY, contentWidth, contentHeight, cornerRadius);
                ctx.clip();
            }
            
            // Draw background and pattern within the clipped area
            drawBackground(ctx, contentX, contentY, contentWidth, contentHeight);
            drawText(ctx);
            
            // Restore context
            ctx.restore();
            
            // Draw border if enabled
            if (enableBorder) {
                ctx.strokeStyle = borderColor;
                ctx.lineWidth = borderWidth;
                
                if (enableRoundedCorners) {
                    roundedRect(ctx, borderWidth/2, borderWidth/2, currentWidth - borderWidth, currentHeight - borderWidth, cornerRadius);
                    ctx.stroke();
                } else {
                    ctx.strokeRect(borderWidth/2, borderWidth/2, currentWidth - borderWidth, currentHeight - borderWidth);
                }
            }
        }

        // Helper function to create rounded rectangle path
        function roundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }

        function drawBackground(ctx, x = 0, y = 0, width = currentWidth, height = currentHeight) {
            const pattern = patterns[currentPattern];
            
            // Get current colors from UI
            const bgColor = document.getElementById('patternBgColor').value;
            const fgColor = document.getElementById('patternFgColor').value;
            
            // Create custom pattern object with current colors
            const customPattern = {
                ...pattern,
                color1: bgColor,
                color2: bgColor,
                accent: fgColor
            };
            
            drawPatternBackground(ctx, customPattern, width, height, x, y);
        }

        function drawPatternBackground(ctx, pattern, width, height, offsetX = 0, offsetY = 0) {
            ctx.save();
            
            // Translate to the offset position
            ctx.translate(offsetX, offsetY);
            
            // Base gradient background
            const gradient = ctx.createLinearGradient(0, 0, width, height);
            gradient.addColorStop(0, pattern.color1);
            gradient.addColorStop(0.5, pattern.color2);
            gradient.addColorStop(1, pattern.color1);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, width, height);
            
            // Set pattern style
            ctx.fillStyle = pattern.accent;
            ctx.strokeStyle = pattern.accent;
            ctx.globalAlpha = 0.25;
            ctx.lineWidth = Math.max(1, width / 400);
            
            // Draw the specific pattern
            switch(pattern.type) {
                case 'starburst':
                    drawStarburst(ctx, width, height);
                    break;
                case 'boomerang':
                    drawBoomerangs(ctx, width, height);
                    break;
                case 'atomic_dots':
                    drawAtomicDots(ctx, width, height);
                    break;
                case 'zigzag':
                    drawZigzag(ctx, width, height);
                    break;
                case 'triangles':
                    drawTriangles(ctx, width, height);
                    break;
                case 'diamond':
                    drawDiamondGrid(ctx, width, height);
                    break;
                case 'waves':
                    drawWaves(ctx, width, height);
                    break;
                case 'retro_stripes':
                    drawRetroStripes(ctx, width, height);
                    break;
                case 'blocks':
                    drawColorBlocks(ctx, width, height);
                    break;
                case 'sunburst':
                    drawSunburst(ctx, width, height);
                    break;
                case 'circles':
                    drawCircles(ctx, width, height);
                    break;
                case 'angular':
                    drawAngularShapes(ctx, width, height);
                    break;
                case 'curves':
                    drawCurves(ctx, width, height);
                    break;
                case 'hexagons':
                    drawHexagons(ctx, width, height);
                    break;
                case 'organic':
                    drawOrganicShapes(ctx, width, height);
                    break;
                case 'atomic_age':
                    drawStarburst(ctx, width, height);
                    ctx.globalAlpha = 0.15;
                    drawAtomicDots(ctx, width, height);
                    break;
                case 'gold_cross':
                    drawGoldCross(ctx, width, height);
                    break;
                case 'kidney':
                    drawKidneyShapes(ctx, width, height);
                    break;
                case 'leaves':
                    drawLeaves(ctx, width, height);
                    break;
                case 'crosses':
                    drawCrosses(ctx, width, height);
                    break;
                default:
                    drawAtomicDots(ctx, width, height);
                    break;
            }
            
            ctx.globalAlpha = 1;
            ctx.restore();
        }

        // Pattern drawing functions with proper scaling
        function drawStarburst(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const rays = 16;
            const maxRadius = Math.min(width, height) * 0.8;
            
            for (let i = 0; i < rays; i++) {
                const angle = (i * 2 * Math.PI) / rays;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * maxRadius,
                    centerY + Math.sin(angle) * maxRadius
                );
                ctx.stroke();
            }
        }

        function drawBoomerangs(ctx, width, height) {
            const size = Math.min(width, height) / 15;
            const spacing = size * 2;
            
            for (let x = 0; x < width + size; x += spacing) {
                for (let y = 0; y < height + size; y += spacing) {
                    ctx.save();
                    ctx.translate(x + (y / spacing % 2) * spacing / 2, y);
                    ctx.rotate((x + y) * 0.01);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.quadraticCurveTo(size * 0.4, -size * 0.3, size * 0.8, 0);
                    ctx.quadraticCurveTo(size * 0.4, size * 0.3, 0, 0);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawAtomicDots(ctx, width, height) {
            const dotCount = Math.min(25, (width * height) / 10000);
            const maxRadius = Math.min(width, height) / 30;
            
            for (let i = 0; i < dotCount; i++) {
                const x = (i % 5 + 0.5) * (width / 5);
                const y = (Math.floor(i / 5) + 0.5) * (height / 5);
                const radius = maxRadius * (0.5 + Math.random() * 0.5);
                
                // Central dot
                ctx.beginPath();
                ctx.arc(x, y, radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Orbital rings
                for (let j = 1; j <= 2; j++) {
                    ctx.beginPath();
                    ctx.arc(x, y, radius * 0.3 + j * radius * 0.4, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        function drawZigzag(ctx, width, height) {
            const spacing = Math.min(width, height) / 12;
            const amplitude = spacing * 0.5;
            
            for (let y = spacing; y < height; y += spacing * 2) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                
                for (let x = 0; x <= width; x += spacing) {
                    const zigY = y + (Math.floor(x / spacing) % 2 === 0 ? amplitude : -amplitude);
                    ctx.lineTo(x, zigY);
                }
                ctx.stroke();
            }
        }

        function drawTriangles(ctx, width, height) {
            const size = Math.min(width, height) / 20;
            const spacing = size * 1.8;
            
            for (let x = 0; x < width + size; x += spacing) {
                for (let y = 0; y < height + size; y += spacing) {
                    ctx.save();
                    ctx.translate(x + (y / spacing % 2) * spacing / 2, y);
                    ctx.rotate((x + y) * 0.01);
                    
                    ctx.beginPath();
                    ctx.moveTo(0, -size/2);
                    ctx.lineTo(size/2, size/2);
                    ctx.lineTo(-size/2, size/2);
                    ctx.closePath();
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawDiamondGrid(ctx, width, height) {
            const size = Math.min(width, height) / 25;
            const spacing = size * 1.5;
            
            for (let x = 0; x < width + spacing; x += spacing) {
                for (let y = 0; y < height + spacing; y += spacing) {
                    if ((Math.floor(x / spacing) + Math.floor(y / spacing)) % 2 === 0) {
                        ctx.save();
                        ctx.translate(x, y);
                        ctx.rotate(Math.PI / 4);
                        ctx.fillRect(-size/2, -size/2, size, size);
                        ctx.restore();
                    }
                }
            }
        }

        function drawWaves(ctx, width, height) {
            const waveHeight = Math.min(width, height) / 30;
            const frequency = 2 * Math.PI / (Math.min(width, height) / 4);
            const spacing = Math.min(width, height) / 8;
            
            for (let y = 0; y < height; y += spacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                
                for (let x = 0; x <= width; x += 5) {
                    const waveY = y + Math.sin(x * frequency) * waveHeight;
                    ctx.lineTo(x, waveY);
                }
                ctx.stroke();
            }
        }

        function drawRetroStripes(ctx, width, height) {
            const stripeWidth = Math.min(width, height) / 25;
            const angle = Math.PI / 6;
            
            ctx.save();
            ctx.translate(width / 2, height / 2);
            ctx.rotate(angle);
            
            const diagonal = Math.sqrt(width * width + height * height);
            for (let x = -diagonal; x < diagonal; x += stripeWidth * 2) {
                ctx.fillRect(x, -diagonal, stripeWidth, diagonal * 2);
            }
            ctx.restore();
        }

        function drawColorBlocks(ctx, width, height) {
            const blockSize = Math.min(width, height) / 15;
            
            for (let x = 0; x < width; x += blockSize) {
                for (let y = 0; y < height; y += blockSize) {
                    if (Math.random() > 0.7) {
                        ctx.fillRect(x, y, blockSize, blockSize);
                    }
                }
            }
        }

        function drawSunburst(ctx, width, height) {
            const centerX = width / 2;
            const centerY = height / 2;
            const rays = 24;
            const outerRadius = Math.min(width, height) * 0.4;
            
            for (let i = 0; i < rays; i++) {
                const angle1 = (i * 2 * Math.PI) / rays;
                const angle2 = ((i + 0.5) * 2 * Math.PI) / rays;
                
                if (i % 2 === 0) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.arc(centerX, centerY, outerRadius, angle1, angle2);
                    ctx.closePath();
                    ctx.fill();
                }
            }
        }

        function drawCircles(ctx, width, height) {
            const circleCount = Math.min(20, (width * height) / 8000);
            const maxRadius = Math.min(width, height) / 15;
            
            for (let i = 0; i < circleCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const radius = Math.random() * maxRadius + maxRadius * 0.3;
                
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function drawAngularShapes(ctx, width, height) {
            const shapeCount = Math.min(25, (width * height) / 6000);
            const maxSize = Math.min(width, height) / 20;
            
            for (let i = 0; i < shapeCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * maxSize + maxSize * 0.5;
                const sides = Math.floor(Math.random() * 4) + 3;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(Math.random() * Math.PI);
                
                ctx.beginPath();
                for (let j = 0; j < sides; j++) {
                    const angle = (j * 2 * Math.PI) / sides;
                    const px = Math.cos(angle) * size;
                    const py = Math.sin(angle) * size;
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        function drawCurves(ctx, width, height) {
            const curveCount = Math.max(5, Math.min(12, width / 200));
            
            for (let i = 0; i < curveCount; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random() * width, Math.random() * height);
                
                for (let j = 0; j < 3; j++) {
                    const cpx = Math.random() * width;
                    const cpy = Math.random() * height;
                    const x = Math.random() * width;
                    const y = Math.random() * height;
                    ctx.quadraticCurveTo(cpx, cpy, x, y);
                }
                ctx.stroke();
            }
        }

        function drawHexagons(ctx, width, height) {
            const size = Math.min(width, height) / 25;
            const hexHeight = size * Math.sqrt(3);
            
            for (let row = 0; row < height / hexHeight + 2; row++) {
                for (let col = 0; col < width / (size * 1.5) + 2; col++) {
                    const x = col * size * 1.5;
                    const y = row * hexHeight + (col % 2) * hexHeight / 2;
                    
                    if ((row + col) % 3 === 0) {
                        ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = i * Math.PI / 3;
                            const px = x + size * Math.cos(angle);
                            const py = y + size * Math.sin(angle);
                            if (i === 0) ctx.moveTo(px, py);
                            else ctx.lineTo(px, py);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }
                }
            }
        }

        function drawOrganicShapes(ctx, width, height) {
            const shapeCount = Math.min(15, (width * height) / 8000);
            const maxSize = Math.min(width, height) / 20;
            
            for (let i = 0; i < shapeCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * maxSize + maxSize * 0.5;
                
                ctx.save();
                ctx.translate(x, y);
                
                ctx.beginPath();
                const points = 8;
                for (let j = 0; j < points; j++) {
                    const angle = (j * 2 * Math.PI) / points;
                    const radius = size * (0.5 + Math.random() * 0.5);
                    const px = Math.cos(angle) * radius;
                    const py = Math.sin(angle) * radius;
                    
                    if (j === 0) ctx.moveTo(px, py);
                    else ctx.lineTo(px, py);
                }
                ctx.closePath();
                ctx.fill();
                ctx.restore();
            }
        }

        function drawGoldCross(ctx, width, height) {
            const spacing = Math.min(width, height) / 12;
            const crossSize = spacing * 0.4;
            
            for (let x = spacing; x < width; x += spacing) {
                for (let y = spacing; y < height; y += spacing) {
                    // Main cross
                    ctx.fillRect(x - crossSize/2, y - crossSize/8, crossSize, crossSize/4);
                    ctx.fillRect(x - crossSize/8, y - crossSize/2, crossSize/4, crossSize);
                    
                    // Corner dots
                    const dotRadius = crossSize / 12;
                    for (let i = 0; i < 4; i++) {
                        const angle = i * Math.PI / 2 + Math.PI / 4;
                        const dx = Math.cos(angle) * crossSize * 0.4;
                        const dy = Math.sin(angle) * crossSize * 0.4;
                        ctx.beginPath();
                        ctx.arc(x + dx, y + dy, dotRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }
        }

        function drawKidneyShapes(ctx, width, height) {
            const spacing = Math.min(width, height) / 15;
            const size = spacing * 0.6;
            
            for (let x = spacing; x < width; x += spacing * 1.5) {
                for (let y = spacing; y < height; y += spacing * 1.5) {
                    ctx.save();
                    ctx.translate(x + (Math.random() - 0.5) * spacing * 0.3, y + (Math.random() - 0.5) * spacing * 0.3);
                    ctx.rotate(Math.random() * Math.PI);
                    
                    ctx.beginPath();
                    ctx.ellipse(0, 0, size, size * 0.7, 0, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        function drawLeaves(ctx, width, height) {
            const leafCount = Math.min(30, (width * height) / 5000);
            const maxSize = Math.min(width, height) / 25;
            
            for (let i = 0; i < leafCount; i++) {
                const x = Math.random() * width;
                const y = Math.random() * height;
                const size = Math.random() * maxSize + maxSize * 0.4;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(Math.random() * Math.PI * 2);
                
                ctx.beginPath();
                ctx.ellipse(0, 0, size, size * 1.5, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        function drawCrosses(ctx, width, height) {
            const spacing = Math.min(width, height) / 15;
            const crossSize = spacing * 0.4;
            
            for (let x = spacing; x < width; x += spacing) {
                for (let y = spacing; y < height; y += spacing) {
                    if (Math.random() > 0.4) {
                        ctx.fillRect(x - crossSize/2, y - crossSize/10, crossSize, crossSize/5);
                        ctx.fillRect(x - crossSize/10, y - crossSize/2, crossSize/5, crossSize);
                    }
                }
            }
        }

        function drawText(ctx) {
            const mainText = document.getElementById('mainText').value || getRandomShakespeareCouplet();
            const author = document.getElementById('authorText').value;
            const fontSize = parseInt(document.getElementById('textSize').value);
            const fontFamily = document.getElementById('fontSelect').value;
            const textColor = document.getElementById('textColor').value;
            
            // Get frame settings to calculate content area
            const enableBorder = document.getElementById('enableBorder').checked;
            const borderWidth = parseInt(document.getElementById('borderWidth').value);
            
            // Calculate content area (inside border)
            const contentX = enableBorder ? borderWidth : 0;
            const contentY = enableBorder ? borderWidth : 0;
            const contentWidth = currentWidth - (enableBorder ? borderWidth * 2 : 0);
            const contentHeight = currentHeight - (enableBorder ? borderWidth * 2 : 0);
            
            // Text styling
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(255,255,255,0.8)';
            ctx.shadowBlur = Math.max(2, fontSize / 20);
            ctx.shadowOffsetX = 1;
            ctx.shadowOffsetY = 1;
            
            // Main text
            ctx.font = `${fontSize}px ${fontFamily}`;
            const lines = wrapTextWithLineBreaks(ctx, mainText, contentWidth * 0.85);
            const lineHeight = fontSize * 1.3;
            const totalTextHeight = lines.length * lineHeight + (author ? fontSize * 0.7 + 20 : 0);
            
            let startY = contentY + (contentHeight - totalTextHeight) / 2;
            let centerX = contentX + contentWidth / 2;
            
            // Draw main text lines
            lines.forEach((line, index) => {
                ctx.fillText(line, centerX, startY + (index * lineHeight) + fontSize / 2);
            });
            
            // Draw author
            if (author) {
                ctx.font = `italic ${fontSize * 0.7}px ${fontFamily}`;
                ctx.fillText('‚Äî ' + author, centerX, startY + totalTextHeight - fontSize * 0.35);
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
        }

        function wrapTextWithLineBreaks(ctx, text, maxWidth) {
            // First split by explicit line breaks
            const paragraphs = text.split('\n');
            const allLines = [];
            
            // Process each paragraph separately
            paragraphs.forEach(paragraph => {
                if (paragraph.trim() === '') {
                    // Handle empty lines (line breaks)
                    allLines.push('');
                } else {
                    // Apply word wrapping to each paragraph
                    const wrappedLines = wrapText(ctx, paragraph, maxWidth);
                    allLines.push(...wrappedLines);
                }
            });
            
            return allLines;
        }

        function wrapText(ctx, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = '';
            
            for (let i = 0; i < words.length; i++) {
                const testLine = currentLine + words[i] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && i > 0) {
                    lines.push(currentLine.trim());
                    currentLine = words[i] + ' ';
                } else {
                    currentLine = testLine;
                }
            }
            lines.push(currentLine.trim());
            return lines;
        }

        function downloadImage() {
            const canvas = document.getElementById('canvas');
            const link = document.createElement('a');
            const filename = `textshot-love-${currentSizeName.replace(/\s+/g, '-').toLowerCase()}-${Date.now()}.png`;
            
            // Create high-quality image
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            
            // White background for better compatibility
            tempCtx.fillStyle = 'white';
            tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
            tempCtx.drawImage(canvas, 0, 0);
            
            link.download = filename;
            link.href = tempCanvas.toDataURL('image/png', 1.0);
            link.click();
            
            showStatus('üéâ Image downloaded successfully!', 'success');
        }

        function copyImage() {
            const canvas = document.getElementById('canvas');
            
            // Try Web Share API first (works on mobile and some desktop browsers)
            if (navigator.share) {
                canvas.toBlob(blob => {
                    const file = new File([blob], 'textshot-love.png', { type: 'image/png' });
                    
                    if (navigator.canShare && navigator.canShare({ files: [file] })) {
                        navigator.share({
                            title: 'TextShot Love',
                            text: 'Check out this beautiful quote image I created!',
                            files: [file]
                        }).then(() => {
                            showStatus('üéâ Shared successfully!', 'success');
                        }).catch((error) => {
                            console.log('Share failed:', error);
                            // Fallback to clipboard
                            tryClipboardCopy(canvas);
                        });
                    } else {
                        // Fallback to clipboard
                        tryClipboardCopy(canvas);
                    }
                });
            } else {
                // Fallback to clipboard for browsers without Web Share API
                tryClipboardCopy(canvas);
            }
        }

        function tryClipboardCopy(canvas) {
            // Try modern Clipboard API
            if (navigator.clipboard && navigator.clipboard.write) {
                canvas.toBlob(blob => {
                    const item = new ClipboardItem({'image/png': blob});
                    navigator.clipboard.write([item]).then(() => {
                        showStatus('üìã Image copied to clipboard!', 'success');
                    }).catch((error) => {
                        console.log('Clipboard write failed:', error);
                        // Final fallback - copy image data URL
                        fallbackCopyMethod(canvas);
                    });
                });
            } else {
                // Fallback for older browsers
                fallbackCopyMethod(canvas);
            }
        }

        function fallbackCopyMethod(canvas) {
            // For browsers that don't support modern clipboard
            try {
                // Create a temporary text area with the data URL
                const dataURL = canvas.toDataURL('image/png');
                const textArea = document.createElement('textarea');
                textArea.value = dataURL;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('üìã Image data copied! Paste into image editor or messaging app.', 'success');
            } catch (error) {
                console.log('Fallback copy failed:', error);
                // Ultimate fallback - offer download
                showStatus('üí° Copy not supported. Use the Download button instead!', 'error');
            }
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = `status ${type}`;
            
            setTimeout(() => {
                status.textContent = '';
                status.className = 'status';
            }, 4000);
        }

        // Initialize the app
        window.addEventListener('load', init);
    </script>
</body>
</html>